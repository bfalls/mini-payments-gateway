<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PrivateCircle Pay Demo</title>
    <link rel="stylesheet" href="/styles.css">
</head>
<body>
    <header class="header">
        <div class="brand">
            <div class="logo" aria-label="PrivateCircle logo">
                <svg width="600"
                     height="220"
                     viewBox="0 0 600 220"
                     xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="ringGradient" x1="0" y1="0" x2="1" y2="1">
                            <stop offset="0%" stop-color="#FF3B30" />
                            <stop offset="50%" stop-color="#C039FF" />
                            <stop offset="100%" stop-color="#007AFF" />
                        </linearGradient>
                    </defs>
                    <circle cx="110"
                            cy="110"
                            r="80"
                            fill="none"
                            stroke="url(#ringGradient)"
                            stroke-width="22" />
                    <text x="210"
                          y="124"
                          fill="#000000"
                          font-family="system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif"
                          font-size="52"
                          font-weight="600">
                        PrivateCircle
                    </text>
                </svg>
            </div>
            <div>
                <div>PrivateCircle Pay Demo</div>
                <small>Fiat + Crypto • Derived idempotency keys • Worker updates</small>
            </div>
        </div>
    </header>

    <main class="main">
        <div class="card">
            <div class="section-title">
                <h2>How this demo works (90-second tour)</h2>
            </div>
            <ol>
                <li>
                    <strong>Card / Fiat flow:</strong>
                    Enter any values you like. Click <em>Derive key</em> to see the server generate an idempotency key
                    and canonical payload — these protect the <code>/payments/charge</code> endpoint from duplicates.
                    Then click <em>Submit payment</em> to create the payment.
                </li>
                <li>
                    <strong>PSP update (worker simulation):</strong>
                    Immediately after submitting, scroll down and click <em>Fetch /payments/</em>.
                    If you beat the worker (10-second polling), the payment will still be <code>Status = 0</code> with no auth code.
                    Try again after 10 seconds, the worker will have called the PSP stub and updated the record with a
                    status + auth code.
                </li>
                <li>
                    <strong>Idempotency behavior:</strong>
                    Submit the exact same values again. The idempotency key and <code>paymentId</code> will be identical,
                    proving no duplicate payment was created.
                </li>
                <li>
                    <strong>Crypto flow:</strong>
                    Works the same as Card / Fiat, but simulates chain confirmations and exposes a secondary crypto endpoint:
                    <code>/payments/{paymentId}/crypto</code>. Both requests can be made from this page.
                </li>
                <li>
                    <strong>What’s happening behind the scenes:</strong>
                    A background worker reads from an outbox table, calls a simulated PSP, and updates each payment record.
                    This shows canonicalization + idempotency + async processing.
                </li>
                <li>
                    <strong>Author</strong>
                    Prepared by Barnaby Falls <a href="https://www.linkedin.com/in/bfalls" target="_blank">LinkedIn</a>,
                    <a href="https://github.com/bfalls/mini-payments-gateway" target="_blank">Github repo</a>.<br />
                    <ul>
                        <li>
                            Project for <b>C#, .NET, Github Actions, Deployed on AWS EC2 in Docker containers</b>, including a Postgres container, and a
                            dynamically updated DNYU domain; to maintain a consistent URL everytime the EC2
                            instance is started with a different IP address.
                        </li>
                    </ul>
                </li>
            </ol>

            <div class="callout">
                <strong>Tip:</strong> For each flow, the typical sequence is:
                <code>Derive key → Submit → Fetch status</code>.
                You can repeat the same request to see idempotent behavior.
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <div class="section-title">
                    <h3>Card / Fiat</h3>
                    <span class="badge">Simulated card authorization via PSP stub</span>
                </div>

                <p class="hint">
                    <strong>Try this flow:</strong>
                    (1) Derive key -> (2) Submit payment -> (3) Fetch payment by ID below.
                </p>

                <label for="fiatAmount">Amount (minor units)</label>
                <input id="fiatAmount" type="number" value="4200" />

                <label for="fiatCurrency">Currency</label>
                <input id="fiatCurrency" value="USD" />

                <label for="fiatToken">Source token</label>
                <input id="fiatToken" value="tok_visa" />

                <label for="fiatMerchantRef">Merchant ref</label>
                <input id="fiatMerchantRef" value="order-1001" />

                <button id="fiatDerive">Derive key</button>
                <button class="secondary" id="fiatSubmit">Submit payment</button>

                <label for="fiatDerived">Derived key</label>
                <input id="fiatDerived" readonly />

                <label for="fiatCanonical">Canonical payload</label>
                <textarea id="fiatCanonical" readonly></textarea>

                <div class="status" id="fiatStatus">Click <strong>Derive key</strong> to see the server-derived idempotency key and payload.</div>

                <div class="section-title">
                    <h4>Track worker updates</h4>
                    <small>
                        After submitting, the worker calls the PSP stub and updates status + auth code.
                        Use this section to watch it. 10-sec polling.
                    </small>
                </div>
                <label for="fiatPaymentId">Payment ID</label>
                <input id="fiatPaymentId" placeholder="Filled after Submit payment" />
                <button class="secondary" id="fiatFetch">Fetch /payments/{paymentId}</button>
                <div class="status" id="fiatFetchStatus">No fetch yet. Submit a payment first.</div>
                <div>status = 0 means Pending (waiting for worker)</div>
                <div>status = 1 means Approved (worker processed / simulated PSP approval)</div>

            </div>

            <div class="card">
                <div class="section-title">
                    <h3>Crypto</h3>
                    <span class="badge">Simulated chain confirmations</span>
                </div>

                <p class="hint">
                    <strong>Try this flow:</strong>
                    (1) Derive key -> (2) Submit crypto -> (3) Fetch payment + crypto tx.
                </p>

                <label for="cryptoAmount">Amount (minor units)</label>
                <input id="cryptoAmount" type="number" value="500000" />

                <label for="cryptoCurrency">Crypto currency</label>
                <input id="cryptoCurrency" value="USDC" />

                <label for="cryptoNetwork">Network</label>
                <input id="cryptoNetwork" value="Ethereum-Testnet" />

                <label for="cryptoFromWallet">From wallet</label>
                <input id="cryptoFromWallet" value="0xU5AF1A6000000000000000000000000000000000" />

                <label for="cryptoMerchantRef">Merchant ref</label>
                <input id="cryptoMerchantRef" value="order-crypto-42" />

                <button id="cryptoDerive">Derive key</button>
                <button class="secondary" id="cryptoSubmit">Submit crypto</button>

                <label for="cryptoDerived">Derived key</label>
                <input id="cryptoDerived" readonly />

                <label for="cryptoCanonical">Canonical payload</label>
                <textarea id="cryptoCanonical" readonly></textarea>

                <div class="status" id="cryptoStatus">Click <strong>Derive key</strong>, then <strong>Submit crypto</strong> to enqueue a simulated chain transaction.</div>

                <div class="section-title">
                    <h4>Track worker updates</h4>
                    <small>
                        The worker simulates confirmations and updates the payment + crypto record.
                        Fetch both from here. 10-sec polling.
                    </small>
                </div>
                <label for="cryptoPaymentId">Payment ID</label>
                <input id="cryptoPaymentId" placeholder="Filled after Submit crypto" />
                <div class="grid">
                    <button class="secondary" id="cryptoFetchPayment">Fetch /payments/{paymentId}</button>
                    <button class="secondary" id="cryptoFetchTx">Fetch /payments/{paymentId}/crypto</button>
                </div>
                <div class="status" id="cryptoFetchStatus">No fetch yet. Submit a crypto payment first.</div>
            </div>
        </div>
    </main>

    <script>
        const BASE_URL = window.location.origin;
        const API_KEY = 'local-dev'; 

        async function postJson(url, payload, idempotencyKey) {
            const headers = {
                'Content-Type': 'application/json',
                'x-api-key': API_KEY
            };
            if (idempotencyKey) headers['Idempotency-Key'] = idempotencyKey;

            const response = await fetch(url, {
                method: 'POST',
                headers,
                body: JSON.stringify(payload)
            });
            const contentType = response.headers.get('content-type') || '';
            const isJson = contentType.includes('application/json');
            const body = isJson ? await response.json() : await response.text();
            return { status: response.status, body };
        }

        async function getJson(url) {
            const response = await fetch(url, {
                method: 'GET',
                headers: { 'x-api-key': API_KEY }
            });
            const contentType = response.headers.get('content-type') || '';
            const isJson = contentType.includes('application/json');
            const body = isJson ? await response.json() : await response.text();
            return { status: response.status, body };
        }

        function buildFiatPayload() {
            return {
                amount: Number(document.getElementById('fiatAmount').value),
                currency: document.getElementById('fiatCurrency').value,
                sourceToken: document.getElementById('fiatToken').value,
                merchantRef: document.getElementById('fiatMerchantRef').value
            };
        }

        function buildCryptoPayload() {
            return {
                amount: Number(document.getElementById('cryptoAmount').value),
                cryptoCurrency: document.getElementById('cryptoCurrency').value,
                network: document.getElementById('cryptoNetwork').value,
                fromWallet: document.getElementById('cryptoFromWallet').value,
                merchantRef: document.getElementById('cryptoMerchantRef').value
            };
        }

        function writeStatus(elementId, data) {
            const el = document.getElementById(elementId);
            el.textContent = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
        }

        async function derive(flow) {
            const payload = flow === 'fiat' ? buildFiatPayload() : buildCryptoPayload();
            const url = `${BASE_URL}/tools/derive-idempotency/${flow === 'fiat' ? 'charge' : 'crypto-charge'}`;
            const result = await postJson(url, payload);

            if (flow === 'fiat') {
                document.getElementById('fiatDerived').value = result.body?.derivedKey || '';
                document.getElementById('fiatCanonical').value = result.body?.canonicalPayload || '';
                writeStatus('fiatStatus', result);
            } else {
                document.getElementById('cryptoDerived').value = result.body?.derivedKey || '';
                document.getElementById('cryptoCanonical').value = result.body?.canonicalPayload || '';
                writeStatus('cryptoStatus', result);
            }
        }

        async function submit(flow) {
            const payload = flow === 'fiat' ? buildFiatPayload() : buildCryptoPayload();
            const derived = flow === 'fiat'
                ? document.getElementById('fiatDerived').value
                : document.getElementById('cryptoDerived').value;

            const url = `${BASE_URL}/payments/${flow === 'fiat' ? 'charge' : 'crypto-charge'}`;
            const result = await postJson(url, payload, derived);

            if (flow === 'fiat') {
                writeStatus('fiatStatus', result);
                if (result.body && result.body.paymentId) {
                    document.getElementById('fiatPaymentId').value = result.body.paymentId;
                }
            } else {
                writeStatus('cryptoStatus', result);
                if (result.body && result.body.paymentId) {
                    document.getElementById('cryptoPaymentId').value = result.body.paymentId;
                }
            }
        }

        async function fetchPaymentStatus(flow) {
            const paymentId = (flow === 'fiat'
                ? document.getElementById('fiatPaymentId')
                : document.getElementById('cryptoPaymentId')).value.trim();

            if (!paymentId) {
                writeStatus(
                    flow === 'fiat' ? 'fiatFetchStatus' : 'cryptoFetchStatus',
                    'Enter or submit a payment to get an id.'
                );
                return;
            }

            const result = await getJson(`${BASE_URL}/payments/${paymentId}`);
            writeStatus(flow === 'fiat' ? 'fiatFetchStatus' : 'cryptoFetchStatus', result);
        }

        async function fetchCryptoTx() {
            const paymentId = document.getElementById('cryptoPaymentId').value.trim();
            if (!paymentId) {
                writeStatus('cryptoFetchStatus', 'Enter or submit a crypto payment to get an id.');
                return;
            }

            const result = await getJson(`${BASE_URL}/payments/${paymentId}/crypto`);
            writeStatus('cryptoFetchStatus', result);
        }

        document.getElementById('fiatDerive').addEventListener('click', () => derive('fiat'));
        document.getElementById('cryptoDerive').addEventListener('click', () => derive('crypto'));
        document.getElementById('fiatSubmit').addEventListener('click', () => submit('fiat'));
        document.getElementById('cryptoSubmit').addEventListener('click', () => submit('crypto'));
        document.getElementById('fiatFetch').addEventListener('click', () => fetchPaymentStatus('fiat'));
        document.getElementById('cryptoFetchPayment').addEventListener('click', () => fetchPaymentStatus('crypto'));
        document.getElementById('cryptoFetchTx').addEventListener('click', fetchCryptoTx);
    </script>

</body>
</html>
